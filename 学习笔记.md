# CMD命令

1. dir：查看当前路径下的内容
2. cls：清屏
3. cd \：回到盘符的根目录
4. exit：退出窗口

# 环境变量

目的：想要在**任意目录下**都可以打开指定的软件

系统变量-Path：记录可执行文件的路径		（顺序查找）

## 配置

1. 配置JAVA_HOME系统变量：路径不带bin
2. 配置Path：%JAVA_HOME%\bin

# 高级语言编译运行步骤

1. 编写程序：文件后缀名必须是java		**类名必须和文件名保持一致**

2. 编译文件：翻译

   ```
   javac xxx.java
   ```

3. 运行程序

   ```
   java xxx // 这里不带后缀
   ```

bin>java.exe运行 + javac.exe编译

# 高级记事本

notepad++

# Java跨平台

通过虚拟机实现，java语言运行在虚拟机中，我们需要针对不同的操作系统，安装不同的虚拟机。

# JRE vs JDK

## JDK

> java development kit：java开发工具包

1. JVM：java virtual machine，java虚拟机，运行java程序
2. 核心类库：java事先定义好的东西
3. 开发工具：javac编译，java运行，jdb调试，jhat内存分析

## JRE

> java runtime environment：java运行环境

1. JVM
2. 核心类库
3. 运行工具

## 包含关系

JDK > JRE > JVM

------

# Java基础语法

## 注释

1. 单行：//
2. 多行：/*    */
3. 文档：/**   */

## 关键字

常见：class

特点：1.全部小写	2.特殊颜色标记

## 字面量

类型：

1. 整数
2. 小数
3. 字符串：双引号
4. 字符：单引号
5. 布尔
6. 空：null（不能直接打印）

### 特殊字符类型字面量：

1. '\t'：制表符，字符串长度补齐为8的整数倍，最少补1个空格，最多补8个空格（表格数据对齐）
2. '\r'
3. '\n'

## 输出

```java
System.out.printf("my name is %s", "wwj"); // 占位符

System.out.println("hello world"); // 可换行
```

## 变量

数据类型：

1. 整数：int
2. 浮点数：double

## 计算机存储规则

### 不同进制

1. 二进制：0b开头	
2. 八进制：0开头
3. 十六进制：0x开头

### ASCII码表

> a：97
>
> A：65

### 图片

1. 分辨率
2. 灰度图：灰度表0~255
3. 彩色图：光学三原色（红、绿、蓝）RGB

### 声音

对声音的波形图采样 + 存储

## 数据类型

### 基本数据类型

1. 整数：byte（1B）、short（2B）、**int**（4B）、long（8B，数值后加*L后缀*）
2. 浮点数：float（4B，数值后加*F后缀*）、**double**（8B）
3. 字符：char（2B）
4. 布尔：boolean（1B）

> 取值范围大小关系：double > float > long > int > short > byte

### 引用数据类型

除了基本数据类型以外，都是引用数据类型。

### 隐式转换（自动类型提升）

> 取值范围小 ---> 取值范围大
>
> byte，short，char这3中类型的数据在运算时会**直接先提升为int**，再进行运算

### 强制转换

> 取值范围大 ---> 取值范围小
>
> (目标数据类型)被强转的数据

## 标识符

命名规则：

1. 必须由数字、字母、_、$组成
2. 区分大小写

建议：

1. 小驼峰：方法、变量
2. 大驼峰：类名

## 键盘录入

> 类：Scanner

演示：见codes

## IDEA

> 全称：Intellij IDEA，java语言开发的集成环境

### 项目结构

1. （项目）project
2. （模块）module：互相独立
3. （包）package：相同功能的代码放到同一个包当中方便管理
4. （类）class

## 原码、反码、补码

正数的原码、反码、补码都是一样的！

原码：最高位为符号位

> 原码在负数运算时出现了**方向相反**的情况，例如-1+1=0，但是原码计算结果为-2，因此设计了反码。

反码：在原码的基础上，符号位不变，其余位均取反

> 反码在计算过程中**跨零**就会产生误差，例如1111,1111（-0）+ 1 = 0000,0000（0），因此设计了补码
>
> 补码就是反码从-0开始的负数向后移一位，即原来的-0表示-1，原来的-1表示-2，这样0唯一，只有+0

补码：反码+1

## 数组

> 存放同种数据类型的多个值

## java内存分配

| 内存空间   | 作用                                                       |
| ---------- | ---------------------------------------------------------- |
| *栈*       | *方法运行时使用的内存，比如main方法运行，进入方法栈中执行* |
| *堆*       | *存储对象或者数组，new来创建的，都存储在堆内存*            |
| 方法区     | 存储可以运行的class文件                                    |
| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关            |
| 寄存器     | 给CPU使用，和我们开发无关                                  |

StringTable串池：在堆内存中，存放直接赋值的字符串（new出来的不是在这里）。

静态区：在堆内存中（静态变量是随着类的加载而加载的，优先于对象出现的）

## 方法

> 作用：
>
> 提高代码复用性
>
> 提高代码可维护性

实参：调用中的参数

形参：方法定义中的参数

### 注意事项：

1. 方法与方法之间是平级关系，不能互相嵌套定义
2. 方法的定义位置与main方法位置前后关系任意

### 方法的重载

> **同一个类**中，定义多个**同名**方法，具有同种功能，每个方法有**不同的参数类型 / 参数个数**，构成**重载**。
>
> 与返回值无关！！

### 方法的内存

栈空间：先进后出

## 面向对象

### 类

> 是对象共同特征的描述

1. 成员变量：代表属性，名词
2. 成员方法：代表行为，动词

注意事项：

1. javabean类：用来描述一类事物的类，不写main方法
2. 测试类：编写main方法，在里面创建javabean类的对象进行赋值调用
3. 一个java文件可以定义多个class类，但只能一个类是public修饰，且该类名必须成为文件名（工作中建议一个文件只写一个类）

### 对象

> 是真实存在的具体的东西

*在java中，要先设计类，才能获取对象*

###  三大特征

#### 封装

> 对象代表什么，就得封装对应的数据，并提供数据对应的行为

#### 继承

> extends	子类（派生类）	父类（基类 / 超类）
>
> 子类的共性抽取到父类，实现代码复用性

特点：只支持单继承，不支持多继承，但支持多层继承

> 直接父类、间接父类
>
> 继承体系的终点是Object类

注意：子类**只能**访问父类中**非私有**的成员

继承内容：

|          | 非私有 | 私有private | 解释                                                     |
| -------- | ------ | ----------- | -------------------------------------------------------- |
| 构造方法 | ×      | ×           | 构造方法名必须与类名保持一致                             |
| 成员变量 | √      | √           | 私有的虽然继承下来了，但是不能直接使用                   |
| 成员方法 | √      | ×           | 虚方法表不会记录私有方法（非private，非static，非final） |

方法重写：

1. 重写方法的名称、形参列表必须与父类中的一致
2. 子类重写父类方法时，访问权限子类必须大于等于父类（空着不写 < protected < public）
3. 子类重写父类方法时，返回值类型子类必须小于等于父类
4. **建议：重写的方法尽量和父类保持一致**
5. 只有被添加到虚方法表中的方法才能被重写

#### 多态

what？同类型的对象，表现出的不同形态

表现形式：父类类型	对象名称	=	子类对象；

前提：

1. 有继承 / 实现关系

2. 有父类引用指向子类对象

   ```java
   Fu f = new Zi();
   ```

3. 有方法重写

### private关键字

> 权限修饰符
>
> 可以修饰成员变量 / 成员方法
>
> 被修饰的成员只能在**本类**中才能访问

### 就近原则

成员变量：类中方法外的变量

局部变量：方法中的变量

> 二者同名时，谁离得近，就代表哪个变量
>
> 这种情况下，要访问成员变量，应该使用**this.名字**
>
> 要访问**父类**的成员变量，应该使用**super.名字**（继承）

### this

> 本质：所在方法调用者的地址值
>
> 作用：区分成员变量和局部变量

### 构造方法

> 修饰符 + 类名（无参 / 带参）

可重载

### 插件：PTG

> 一键生成标准的javabean类

也可以使用快捷键：alt + insert（alt + fn + insert）

### 对象内存图

生成对象的全过程：视频P87

1. 加载class文件（字节码文件）（方法区临时存储）
2. 申明局部变量
3. 在堆内存中开辟一个空间
4. 默认初始化
5. 显式初始化（在类中给成员变量默认值）
6. 构造方法初始化（new对象的时候传递的值）
7. 将堆内存中的地址值赋值给左边的局部变量

### API

> application programming interface：应用程序编程接口
>
> 简单说：别人已经写好的东西，直接用

## 字符串

### StringBuilder

> 可以看成一个容器，里面的内容可变
>
> 作用：提高字符串的操作效率

### 拼接

```java
// 不带变量的拼接
String s1 = "a" + "b" + "c"; // 在编译的时候会直接计算为"abc"放到串池中
// 带变量的拼接
String s2 = s1 + "d"; // 会先在堆中创建一个StringBuilder对象，拼接后再创建一个String对象
/*
JDK8以前：系统底层会自动创建一个StringBuilder对象，然后再调用其append方法完成拼接。拼接后，再调用其toString方法转换为String类型，而toString方法的底层是直接new了一个字符串对象。

JDK8版本：系统会预估要字符串拼接之后的总大小，把要拼接的内容都放在数组中，此时也是产生一个新的字符串。
*/

/*
使用StringBuilder优化拼接的好处：
不会创建很多无用的空间，节约内存。
*/
```

## 集合

> 容器、内容可变、自动扩容
>
> 注意：不能直接存储基本数据类型，必须存为包装类

包装类：

int --- Integer

char --- Character

------

## 面向对象进阶

### static

> 表示静态，修饰成员变量、成员方法

#### 静态变量

特点：

1. 被该类所有对象**共享**
2. 不属于对象，属于类
3. 随着类的加载而加载，优先于对象存在

调用方式：

1. 类名调用（推荐）
2. 对象名调用

#### 静态方法

特点：

1. 多用在测试类和工具类中
2. javabean类中很少会用

调用方式：

1. 类名调用（推荐）
2. 对象名调用

#### 注意事项

1. 静态方法中，只能访问静态
2. 非静态方法可以访问所有
3. 静态方法中没有this关键字

### 工具类

1. 类名语义化，例如Math
2. 私有化构造方法（不让外界创建它的对象）
3. 方法定义为静态

### 包

作用：实质上就是文件夹，用来管理各种不同功能的java类。

包名规则：公司域名反写 + 包的作用，全部英文小写。

全类名

```java
com.wwj.polymorphic.Student s = new com.wwj.polymorphic.Student();
```

导包

```java
import com.wwj.polymorphic.Student;
Student s = new Student();
```

### final

可以修饰：

1. 方法：不能被重写（场景：描述一种规则）
2. 类：不能被继承
3. 变量：常量

常量命名：

1. 单个单词：全部大写
2. 多个单词：全部大写，单词之间用下划线隔开

### 权限修饰符

> 作用范围：private < 空着不写（缺省 / 默认） < protected < public

| 修饰符    | 同一个类中 | 同一个包中其他类 | 不同包下的子类（继承） | 不同包下的无关类（无继承） |
| --------- | :--------: | :--------------: | :--------------------: | :------------------------: |
| private   |     √      |                  |                        |                            |
| 空着不写  |     √      |        √         |                        |                            |
| protected |     √      |        √         |           √            |                            |
| public    |     √      |        √         |           √            |             √              |

实际开发中，一般只使用private和public。

- 成员变量私有
- 方法公开（抽取的共性方法私有）

### 代码块

局部代码块

构造代码块

- 写在成员位置的代码块
- 作用：可以把多个构造方法中重复的代码抽取出来
- 执行时机：我们在创建本类对象的时候会**先执行构造代码块**再执行构造方法

静态代码块

- 执行时机：随着类的加载而加载，并且**只执行一次**。

### 抽象类

抽象方法：在父类中不能确定**具体的方法体**，该方法就可以定义为抽象方法。

抽象类：在该类中**存在**抽象方法，就**必须**声明为抽象类。

注意事项：

1. 不能实例化
2. 抽象类中不一定有抽象方法，但是有抽象方法的类一定是抽象类
2. 可以有构造方法
3. 抽象类的子类，要么**重写所有**抽象方法，要么**是抽象类**

定义抽象方法的**好处**：强制子类必须按照这种格式进行重写。

### 接口

> 就是一种规则，是对行为的抽象。

- 定义：interface

- 不能实例化

- 接口和类之间是实现关系，implements表示

- 接口的子类（实现类）要么重写接口中所有的抽象方法，要么是抽象类

- 一个类可以实现多个接口

  ```java
  public class 类名 extends 父类 implements 接口名1, 接口名2 {}
  ```

> 场景：部分动物有游泳的行为，但不是所有动物都会游泳（因此不能将游泳这个行为写在父类中），提供接口作为行为和部分动物产生联系。

成员特点：

1. 成员变量

   只能是常量

   默认修饰符：public static final

2. 构造方法：没有

3. 成员方法

   jdk7以前：只能是抽象方法

   jdk8：可以有方法体（为了子类不重写不报错，接口升级时）

   **默认**方法：default（不强制要求重写）
   
   ```java
   public default 返回值类型 方法名（参数列表）{ }
   ```
   
   **静态**方法：static（只能通过接口名调用，不能被重写！）
   
   ```java
   public static 返回值类型 方法名（参数列表）{ }
   ```
   
   > 静态方法不会添加到虚方法表中，因此不存在重写这么一说。
   
   jdk9：可以定义私有方法（将接口中方法体部分的重复代码抽取出来）
   
   private（此方法**只为本接口**提供服务，不需要外类访问）
   
   ```java
   private void show() {}        // 普通的私有方法，给接口中的默认方法服务的
   private static void show() {} // 静态的私有方法，给接口中的静态方法服务的
   ```

接口多态：

> 某个方法的参数是接口类型，可以传递该接口所有的实现类对象

适配器模式：在接口和实现类中间增加了一层，重写所有的方法（方法体均为空）。（解决强制重写报错）

### 内部类

> 表示外部类的一部分，单独出现无意义，例如汽车和发动机。

成员内部类

静态内部类：static（**只能**访问外部类的静态变量和静态方法）

局部内部类：方法中
