# CMD命令

1. dir：查看当前路径下的内容
2. cls：清屏
3. cd \：回到盘符的根目录
4. exit：退出窗口

# 环境变量

目的：想要在**任意目录下**都可以打开指定的软件

系统变量-Path：记录可执行文件的路径		（顺序查找）

## 配置

1. 配置JAVA_HOME系统变量：路径不带bin
2. 配置Path：%JAVA_HOME%\bin

# 高级语言编译运行步骤

1. 编写程序：文件后缀名必须是java		**类名必须和文件名保持一致**

2. 编译文件：翻译

   ```
   javac xxx.java
   ```

3. 运行程序

   ```
   java xxx // 这里不带后缀
   ```

bin>java.exe运行 + javac.exe编译

# 高级记事本

notepad++

# Java跨平台

通过虚拟机实现，java语言运行在虚拟机中，我们需要针对不同的操作系统，安装不同的虚拟机。

# JRE vs JDK

## JDK

> java development kit：java开发工具包

1. JVM：java virtual machine，java虚拟机，运行java程序
2. 核心类库：java事先定义好的东西
3. 开发工具：javac编译，java运行，jdb调试，jhat内存分析

## JRE

> java runtime environment：java运行环境

1. JVM
2. 核心类库
3. 运行工具

## 包含关系

JDK > JRE > JVM

------

# Java基础语法

## 注释

1. 单行：//
2. 多行：/*    */
3. 文档：/**   */

## 关键字

常见：class

特点：1.全部小写	2.特殊颜色标记

## 字面量

类型：

1. 整数
2. 小数
3. 字符串：双引号
4. 字符：单引号
5. 布尔
6. 空：null（不能直接打印）

### 特殊字符类型字面量：

1. '\t'：制表符，字符串长度补齐为8的整数倍，最少补1个空格，最多补8个空格（表格数据对齐）
2. '\r'
3. '\n'

## 输出

```java
System.out.printf("my name is %s", "wwj"); // 占位符

System.out.println("hello world"); // 可换行
```

## 变量

数据类型：

1. 整数：int
2. 浮点数：double

## 计算机存储规则

### 不同进制

1. 二进制：0b开头	
2. 八进制：0开头
3. 十六进制：0x开头

### ASCII码表

> a：97
>
> A：65

### 图片

1. 分辨率
2. 灰度图：灰度表0~255
3. 彩色图：光学三原色（红、绿、蓝）RGB

### 声音

对声音的波形图采样 + 存储

## 数据类型

### 基本数据类型

1. 整数：byte（1B）、short（2B）、**int**（4B）、long（8B，数值后加*L后缀*）
2. 浮点数：float（4B，数值后加*F后缀*）、**double**（8B）
3. 字符：char（2B）
4. 布尔：boolean（1B）

> 取值范围大小关系：double > float > long > int > short > byte

### 引用数据类型

除了基本数据类型以外，都是引用数据类型。

### 隐式转换（自动类型提升）

> 取值范围小 ---> 取值范围大
>
> byte，short，char这3中类型的数据在运算时会**直接先提升为int**，再进行运算

### 强制转换

> 取值范围大 ---> 取值范围小
>
> (目标数据类型)被强转的数据

## 标识符

命名规则：

1. 必须由数字、字母、_、$组成
2. 区分大小写

建议：

1. 小驼峰：方法、变量
2. 大驼峰：类名

## 键盘录入

> 类：Scanner

演示：见codes

## IDEA

> 全称：Intellij IDEA，java语言开发的集成环境

### 项目结构

1. （项目）project
2. （模块）module：互相独立
3. （包）package：相同功能的代码放到同一个包当中方便管理
4. （类）class

## 原码、反码、补码

正数的原码、反码、补码都是一样的！

原码：最高位为符号位

> 原码在负数运算时出现了**方向相反**的情况，例如-1+1=0，但是原码计算结果为-2，因此设计了反码。

反码：在原码的基础上，符号位不变，其余位均取反

> 反码在计算过程中**跨零**就会产生误差，例如1111,1111（-0）+ 1 = 0000,0000（0），因此设计了补码
>
> 补码就是反码从-0开始的负数向后移一位，即原来的-0表示-1，原来的-1表示-2，这样0唯一，只有+0

补码：反码+1

## 数组

> 存放同种数据类型的多个值

## java内存分配

| 内存空间   | 作用                                                       |
| ---------- | ---------------------------------------------------------- |
| *栈*       | *方法运行时使用的内存，比如main方法运行，进入方法栈中执行* |
| *堆*       | *存储对象或者数组，new来创建的，都存储在堆内存*            |
| 方法区     | 存储可以运行的class文件                                    |
| 本地方法栈 | JVM在使用操作系统功能的时候使用，和我们开发无关            |
| 寄存器     | 给CPU使用，和我们开发无关                                  |

StringTable串池：在堆内存中，存放直接赋值的字符串（new出来的不是在这里）。

## 方法

> 作用：
>
> 提高代码复用性
>
> 提高代码可维护性

实参：调用中的参数

形参：方法定义中的参数

### 注意事项：

1. 方法与方法之间是平级关系，不能互相嵌套定义
2. 方法的定义位置与main方法位置前后关系任意

### 方法的重载

> **同一个类**中，定义多个**同名**方法，具有同种功能，每个方法有**不同的参数类型 / 参数个数**，构成**重载**。
>
> 与返回值无关！！

### 方法的内存

栈空间：先进后出

## 面向对象

### 类

> 是对象共同特征的描述

1. 成员变量：代表属性，名词
2. 成员方法：代表行为，动词

注意事项：

1. javabean类：用来描述一类事物的类，不写main方法
2. 测试类：编写main方法，在里面创建javabean类的对象进行赋值调用
3. 一个java文件可以定义多个class类，但只能一个类是public修饰，且该类名必须成为文件名（工作中建议一个文件只写一个类）

### 对象

> 是真实存在的具体的东西

*在java中，要先设计类，才能获取对象*

###  三大特征

1. 封装

   > 对象代表什么，就得封装对应的数据，并提供数据对应的行为

2. 继承

3. 多态

### private关键字

> 权限修饰符
>
> 可以修饰成员变量 / 成员方法
>
> 被修饰的成员只能在**本类**中才能访问

### 就近原则

成员变量：类中方法外的变量

局部变量：方法中的变量

> 二者同名时，谁离得近，就代表哪个变量
>
> 这种情况下，要访问成员变量，应该使用**this.名字**

### this

> 本质：所在方法调用者的地址值
>
> 作用：区分成员变量和局部变量

### 构造方法

> 修饰符 + 类名（无参 / 带参）

可重载

### 插件：PTG

> 一键生成标准的javabean类

也可以使用快捷键：alt + insert（alt + fn + insert）

### 对象内存图

生成对象的全过程：视频P87

1. 加载class文件（字节码文件）（方法区临时存储）
2. 申明局部变量
3. 在堆内存中开辟一个空间
4. 默认初始化
5. 显式初始化（在类中给成员变量默认值）
6. 构造方法初始化（new对象的时候传递的值）
7. 将堆内存中的地址值赋值给左边的局部变量

### API

> application programming interface：应用程序编程接口
>
> 简单说：别人已经写好的东西，直接用

## 字符串

### StringBuilder

> 可以看成一个容器，里面的内容可变
>
> 作用：提高字符串的操作效率

### 拼接

```java
// 不带变量的拼接
String s1 = "a" + "b" + "c"; // 在编译的时候会直接计算为"abc"放到串池中
// 带变量的拼接
String s2 = s1 + "d"; // 会先在堆中创建一个StringBuilder对象，拼接后再创建一个String对象
/*
JDK8以前：系统底层会自动创建一个StringBuilder对象，然后再调用其append方法完成拼接。拼接后，再调用其toString方法转换为String类型，而toString方法的底层是直接new了一个字符串对象。

JDK8版本：系统会预估要字符串拼接之后的总大小，把要拼接的内容都放在数组中，此时也是产生一个新的字符串。
*/

/*
使用StringBuilder优化拼接的好处：
不会创建很多无用的空间，节约内存。
*/
```

## 集合

> 容器、内容可变、自动扩容
>
> 注意：不能直接存储基本数据类型，必须存为包装类

包装类：

int --- Integer

char --- Character

